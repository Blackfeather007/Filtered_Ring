import FilteredRing.Basic
import FilteredRing.indexed_category

universe o u v w

open Pointwise CategoryTheory

variable {R : Type u} {Œπ : Type v} [Ring R] [OrderedAddCommMonoid Œπ] {œÉ : Type o} [SetLike œÉ R]
  (F : Œπ ‚Üí œÉ)

structure FilteredModuleCat where
  Mod : ModuleCat.{w, u} R
  {œÉMod : Type*}
  [instSetLike : SetLike œÉMod Mod.carrier]
  [instAddSubmonoidClass : AddSubmonoidClass œÉMod Mod.carrier]
  fil : Œπ ‚Üí œÉMod
  [f : FilteredModule F fil]

attribute [instance] FilteredModuleCat.instSetLike FilteredModuleCat.instAddSubmonoidClass
  FilteredModuleCat.f

instance {M : FilteredModuleCat F} : IndexedModuleCat F where
  Mod := M.Mod
  œÉMod := M.œÉMod
  instSetLike := M.instSetLike
  instAddSubmonoidClass := M.instAddSubmonoidClass
  fil := M.fil
  f := {smul_mem := fun _ _ _ _ ha hb ‚Ü¶ M.f.smul_mem ha hb}

namespace FilteredModuleCat

instance {M : FilteredModuleCat F} {i : Œπ} : AddSubmonoid M.Mod where
  carrier := Set.range (AddSubmonoidClass.subtype (M.fil i))
  add_mem' {a b} ha hb := by
    rw [AddSubmonoidClass.coe_subtype, Subtype.range_coe_subtype, Set.mem_setOf_eq] at *
    exact add_mem ha hb
  zero_mem' := by
    show 0 ‚àà Set.range ‚áë(AddSubmonoidClass.subtype (M.fil i))
    rw [AddSubmonoidClass.coe_subtype, Subtype.range_coe_subtype, Set.mem_setOf_eq]
    exact zero_mem (M.fil i)

instance filteredModuleCategory : Category (FilteredModuleCat F) where
  Hom M N := {f : M.Mod ‚Üí‚Çó[R] N.Mod //
    ‚àÄ i, f '' Set.range (AddSubmonoidClass.subtype (M.fil i))
    ‚â§ Set.range (AddSubmonoidClass.subtype (N.fil i))}
  id _ := ‚ü®LinearMap.id, fun i ‚Ü¶ by
    simp only [LinearMap.id_coe, id_eq, Set.image_id', le_refl]‚ü©
  comp f g := ‚ü®g.1.comp f.1, fun i ‚Ü¶ by
    have aux1 := f.2 i
    have aux2 := g.2 i
    simp only [Set.le_eq_subset, Set.image_subset_iff] at *
    exact fun _ hx ‚Ü¶ aux2 <| aux1 hx‚ü©
  id_comp _ := rfl
  comp_id _ := rfl
  assoc _ _ _ := rfl

instance {M N : FilteredModuleCat F} : FunLike (M ‚ü∂ N) M.1 N.1 where
  coe f := f.1.toFun
  coe_injective' _ _ h := propext Subtype.val_inj |>.symm.mpr <| DFunLike.coe_injective' h

instance filteredModuleConcreteCategory : ConcreteCategory (FilteredModuleCat F) where
  forget :=
    { obj := fun R ‚Ü¶ R.Mod
      map := fun f ‚Ü¶ f.val }
  forget_faithful := ‚ü®fun {_ _} ‚¶É_ _‚¶Ñ ht ‚Ü¶ Subtype.val_inj.mp (LinearMap.ext_iff.mpr (congrFun ht))‚ü©

@[simp] lemma forget_map {M N : FilteredModuleCat F} (f : M ‚ü∂ N) :
  (forget (FilteredModuleCat F)).map f = (f : M.Mod ‚Üí N.Mod) := rfl

/-- The object in the category of R-filt associated to an filtered R-module -/
def of {X : Type w} [AddCommGroup X] [Module R X] {œÉX : Type*} [SetLike œÉX X]
  [AddSubmonoidClass œÉX X] (filX : Œπ ‚Üí œÉX) [FilteredModule F filX] : FilteredModuleCat F where
    Mod := ModuleCat.of R X
    œÉMod := œÉX
    instAddSubmonoidClass := by trivial
    fil := filX

instance {X : FilteredModuleCat F} : FilteredModule F X.fil := X.f

@[simp] theorem of_coe (X : FilteredModuleCat F) : of F X.fil = X := rfl

@[simp] theorem coe_of (X : Type w) [AddCommGroup X] [Module R X] {œÉX : Type*} [SetLike œÉX X]
  [AddSubmonoidClass œÉX X] (filX : Œπ ‚Üí œÉX) [FilteredModule F filX] : (of F filX).1 = X := rfl

/-- A `LinearMap` with degree 0 is a morphism in `Module R`. -/
def ofHom {X Y : Type w} {œÉX œÉY : Type o} [AddCommGroup X] [Module R X] [SetLike œÉX X]
  [AddSubmonoidClass œÉX X] (filX : Œπ ‚Üí œÉX) [FilteredModule F filX] [AddCommGroup Y] [Module R Y]
  [SetLike œÉY Y] [AddSubmonoidClass œÉY Y] (filY : Œπ ‚Üí œÉY) [FilteredModule F filY] (f : X ‚Üí‚Çó[R] Y)
  (deg0 : ‚àÄ i, f '' Set.range (AddSubmonoidClass.subtype (filX i))
    ‚â§ Set.range (AddSubmonoidClass.subtype (filY i))) :
    of F filX ‚ü∂ of F filY :=
    ‚ü®f, deg0‚ü©

-- @[simp 1100] ‚Üê ÊúâlintÈîôËØØ
theorem ofHom_apply {X Y : Type w} {œÉX œÉY : Type o} [AddCommGroup X] [Module R X] [SetLike œÉX X]
  [AddSubmonoidClass œÉX X] (filX : Œπ ‚Üí œÉX) [FilteredModule F filX] [AddCommGroup Y] [Module R Y]
  [SetLike œÉY Y] [AddSubmonoidClass œÉY Y] (filY : Œπ ‚Üí œÉY) [FilteredModule F filY] (f : X ‚Üí‚Çó[R] Y)
  (deg0 : ‚àÄ i, f '' Set.range (AddSubmonoidClass.subtype (filX i))
    ‚â§ Set.range (AddSubmonoidClass.subtype (filY i))) (x : X) :
  ofHom F filX filY f deg0 x = f x := rfl

/-- Forgetting to the underlying type and then building the bundled object returns the original
filtered module. -/
-- Have no idea what ‚Üë means...
@[simps]
def ofSelfIso (M : FilteredModuleCat F) : of F M.fil ‚âÖ M where
  hom := ùüô M
  inv := ùüô M

@[simp]
theorem id_apply {M : FilteredModuleCat F} (m : M.1) : (ùüô M : M.1 ‚Üí M.1) m = m := rfl

@[simp]
theorem coe_comp {M N U : FilteredModuleCat F} (f : M ‚ü∂ N) (g : N ‚ü∂ U) :
  (f ‚â´ g : M.1 ‚Üí U.1) = g ‚àò f := rfl

-- instance : Inhabited (FilteredModuleCat F) := {
--   default := {
--     Mod := ModuleCat.of R PUnit
--     œÉMod := (‚ä§ : AddSubmonoid (Mod F))

--   }
-- }

private instance {M N : FilteredModuleCat F} : AddSemigroup (M ‚ü∂ N) where
  add f g := ‚ü®f.1 + g.1, by
    simp only [Set.le_eq_subset, Set.image_subset_iff]
    intro i _ hx
    have aux1 := f.2 i
    have aux2 := g.2 i
    simp only [AddSubmonoidClass.coe_subtype, Subtype.range_coe_subtype, Set.le_eq_subset,
      Set.image_subset_iff, Set.preimage_setOf_eq] at *
    exact add_mem (aux1 hx) (aux2 hx)‚ü©
  add_assoc a b c := propext Subtype.val_inj |>.symm.mpr
    <| add_assoc a.1 b.1 c.1

private instance {M N : FilteredModuleCat F} : AddCommMonoid (M ‚ü∂ N) where
  zero := ‚ü®0, fun i ‚Ü¶ by
    simp only [Set.le_eq_subset]
    repeat rw [AddSubmonoidClass.coe_subtype, Subtype.range_coe_subtype]
    rw [Set.image_subset_iff]
    exact fun a _ ‚Ü¶ zero_mem (N.fil i)‚ü©
  zero_add a := propext Subtype.val_inj |>.symm.mpr
    <| AddZeroClass.zero_add a.1
  add_zero a := propext Subtype.val_inj |>.symm.mpr
    <| AddZeroClass.add_zero a.1
  nsmul k f := ‚ü®k ‚Ä¢ f.1, by
    simp only [Set.le_eq_subset, Set.image_subset_iff]
    intro i _ hx
    have aux := f.2 i
    simp only [AddSubmonoidClass.coe_subtype, Subtype.range_coe_subtype, Set.mem_setOf_eq,
      Set.le_eq_subset, Set.image_subset_iff, Set.preimage_setOf_eq] at *
    exact nsmul_mem (aux hx) k‚ü©
  nsmul_zero _ := by
    simp only [Set.le_eq_subset, zero_smul]; rfl
  nsmul_succ n x := propext Subtype.val_inj |>.symm.mpr
    <| succ_nsmul x.1 n
  add_comm f g := propext Subtype.val_inj |>.symm.mpr
    <| AddCommMagma.add_comm f.1 g.1

private instance {M N : FilteredModuleCat F} [AddSubgroupClass N.œÉMod N.Mod.carrier] :
  SubNegMonoid (M ‚ü∂ N) where
  zsmul k f := ‚ü®k ‚Ä¢ f.1, by
    simp only [Set.le_eq_subset, LinearMap.smul_apply, Set.image_subset_iff]
    intro i _ hx
    have aux := f.2 i
    simp only [AddSubmonoidClass.coe_subtype, Subtype.range_coe_subtype, Set.mem_setOf_eq,
      Set.le_eq_subset, Set.image_subset_iff, Set.preimage_setOf_eq] at *
    exact zsmul_mem (aux hx) k‚ü©
  neg f := ‚ü®- f.1, by
    simp only [Set.le_eq_subset, LinearMap.neg_apply, Set.image_subset_iff]
    intro i _ hx
    have aux := f.2 i
    simp only [AddSubmonoidClass.coe_subtype, Subtype.range_coe_subtype, Set.mem_setOf_eq,
      Set.le_eq_subset, Set.image_subset_iff, Set.preimage_setOf_eq,
      neg_mem_iff] at *
    exact aux hx‚ü©
  zsmul_zero' f := by
    simp only [Set.le_eq_subset, zero_smul]; rfl
  zsmul_succ' k f := by
    rw [‚Üê Subtype.val_inj]
    simp only [Nat.succ_eq_add_one, Int.ofNat_eq_coe, Nat.cast_one, Set.le_eq_subset, natCast_zsmul]
    exact succ_nsmul f.1 k
  zsmul_neg' k f := by
    rw [‚Üê Subtype.val_inj]
    simp only [Set.le_eq_subset, negSucc_zsmul, Nat.cast_add, Nat.cast_one, neg_inj]
    norm_cast

instance {M N : FilteredModuleCat F} [AddSubgroupClass N.œÉMod N.Mod.carrier] :
  AddCommGroup (M ‚ü∂ N) where
  neg_add_cancel f := propext Subtype.val_inj |>.symm.mpr
    <| neg_add_cancel f.1
  add_comm := AddCommMagma.add_comm

instance (h : ‚àÄ P : FilteredModuleCat F, AddSubgroupClass P.œÉMod P.Mod.carrier) :
  Preadditive (FilteredModuleCat F) where
  add_comp P Q R f f' g := by
    exact propext Subtype.val_inj |>.symm.mpr <| LinearMap.comp_add f.1 f'.1 g.1

private def F' (m : ModuleCat.{w, u} R) := fun i ‚Ü¶
  AddSubmonoid.closure {x | ‚àÉ r ‚àà F i, ‚àÉ a : m.1, x = r ‚Ä¢ a}

private def proofGP (m : ModuleCat.{w, u} R) (i j : Œπ) (x : R) : AddSubmonoid m.1 := {
  carrier := {z | x ‚Ä¢ z ‚àà F' F m (j + i)}
  add_mem' := fun {a b} ha hb ‚Ü¶ by
    simp only [F', Set.mem_setOf_eq, smul_add]
    exact AddSubmonoid.add_mem (AddSubmonoid.closure {x | ‚àÉ r ‚àà F (j + i), ‚àÉ a, x = r ‚Ä¢ a}) ha hb
  zero_mem' :=
    congrArg (Membership.mem (F' F m (j + i))) (smul_zero x) |>.mpr (F' F m (j + i)).zero_mem }

open AddSubmonoid in
instance toFilteredModule (m : ModuleCat.{w, u} R) [FilteredRing F] :
  FilteredModule F (F' F m) where
  mono := fun hij ‚Ü¶ by
    simp only [F', closure_le]
    rintro x ‚ü®r, ‚ü®hr, ‚ü®a, ha‚ü©‚ü©‚ü©
    exact mem_closure.mpr fun K hk ‚Ü¶ hk <| Exists.intro r ‚ü®FilteredRing.mono hij hr,
      Exists.intro a ha‚ü©
  smul_mem {j i x y} hx hy := by
    have : F' F m i ‚â§ proofGP F m i j x := by
      apply closure_le.2
      rintro h ‚ü®r', hr', ‚ü®a, ha‚ü©‚ü©
      exact ha.symm ‚ñ∏ mem_closure.mpr fun K hk ‚Ü¶ hk ‚ü®x * r', ‚ü®FilteredRing.mul_mem hx hr',
        ‚ü®a, smul_smul x r' a‚ü©‚ü©‚ü©
    exact this hy

open AddSubmonoid in
def DeducedFunctor [FilteredRing F] : CategoryTheory.Functor (ModuleCat.{w, u} R)
  (FilteredModuleCat F) where
    obj m := { Mod := m, fil := F' F m, f := toFilteredModule F m }
    map := fun {X Y} hom ‚Ü¶ ‚ü®hom, by
      rintro i p ‚ü®x, ‚ü®hx1, hx2‚ü©‚ü©
      set toAddGP := (closure {x : Y.1 | ‚àÉ r ‚àà F i, ‚àÉ a, x = r ‚Ä¢ a}).comap hom.toAddMonoidHom
      rw [AddSubmonoidClass.coe_subtype, Subtype.range_coe_subtype, Set.mem_setOf_eq] at *
      suffices x ‚àà toAddGP from hx2.symm ‚ñ∏ this
      suffices closure {x : X.1 | ‚àÉ r ‚àà F i, ‚àÉ a, x = r ‚Ä¢ a} ‚â§ toAddGP from this hx1
      suffices {x : X.1 | ‚àÉ r ‚àà F i, ‚àÉ a, x = r ‚Ä¢ a} ‚äÜ hom ‚Åª¬π' {x : Y.1 | ‚àÉ r ‚àà F i, ‚àÉ a, x = r ‚Ä¢ a}
        from by
          apply closure_le.2
          exact fun ‚¶É_‚¶Ñ t ‚Ü¶ subset_closure (this t)
      simp only [Set.preimage_setOf_eq, Set.setOf_subset_setOf, forall_exists_index, and_imp]
      exact fun a x hx x' hx' ‚Ü¶ ‚ü®x, ‚ü®hx, (congrArg (fun t ‚Ü¶ ‚àÉ a, hom t = x ‚Ä¢ a) hx').mpr
        <| (congrArg (fun t ‚Ü¶ ‚àÉ a, t = x ‚Ä¢ a) (map_smul hom x x')).mpr <|
          exists_apply_eq_apply' (HSMul.hSMul x) (hom x')‚ü©‚ü©‚ü©

/-- ! To-do

instance : Inhabited (ModuleCat R) :=
  ‚ü®of R PUnit‚ü©

instance ofUnique {X : Type v} [AddCommGroup X] [Module R X] [i : Unique X] : Unique (of R X) :=
  i -/
example : 1 = 1 := rfl

end FilteredModuleCat
